---
layout: page
title: 为了不让对方孤独努力的活着
categories: [软件方法]
tags: [代码规范，代码重构，设计方式]
---

### 数据、对象的反对称性

*   数据结构、对象或者说具体、抽象的本质区别在于是否暴露数据细节。
*   过程式代码便于添加新函数，不便于添加新数据结构。对象式代码便于添加新类，不便于添加新函数

### 错误处理

*   封装第三方类同时封装其catch异常
*   不要返回、传递null

### 边界

*   慎用类似map等可以使用泛型的接口
ap<Sensor> sensors = new HashMap<Sensor>();
Sensor s = sensors.get(sensorId );
建议替换为
public class Sensors {
	private Map sensors = new HashMap();
	public Sensor getById(String id) { 
		return (Sensor) sensors.get(id);
	}
//snip 
}
*   学习性测试，通过测试驱动了解第三方库
*   为尚未开发的代码预留接口，如适配器模式

### 单元测试

*   只编写刚好失败的单元测试
*   整洁
*   一个测试一个概念

### 类

*   当类名无法准确、完全的描述类的职责时，它太大了。单一权责，保持内聚。
*   为了修改而组织

### 系统

没看懂

### 迭进

*   运行所有测试
*   不可重复。可以用模板类消除明显的重复
*   注意代码的表达力
*   使用恰当数量的类和方法

### 并发编程

*   单一权责，分离不需要并发的代码
*   限制数据作用域，严格限制共享数据的访问
*   使用数据副本
*   线程尽可能独立
*   多了解并发类
*   了解并发的执行模式：限定资源，互斥，线程饥饿，死锁，活锁
*   常用基础算法--生产者、消费者；读者、作者；宴席哲学家
*   避免使用一个共享对象的多个方法，可以：基于客户端锁定，基于服务端锁定，适配服务端
*   尽可能缩小同步区
*   尽早考虑关闭系统的问题，因为有各种可能会死锁
*   编写可插拔，可调整的线程代码，运行多于处理器数量的线程，在不同平台上运行，强迫错误发生。在不同的编程配置，系统配置，负载下频繁运行。
*   java中装置试错代码  没看懂


